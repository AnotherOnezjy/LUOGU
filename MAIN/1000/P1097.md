# [NOIP2007 提高组] 统计数字

## 题目背景

#警告：数据可能存在加强

## 题目描述

某次科研调查时得到了$n$个自然数，每个数均不超过$1500000000(1.5 \times 10^9)$。已知不相同的数不超过$10000$个，现在需要统计这些自然数各自出现的次数，并按照自然数从小到大的顺序输出统计结果。

## 输入格式

共$n+1$行。

第一行是整数$n$，表示自然数的个数；

第$2$至$n+1$每行一个自然数。

## 输出格式

共$m$行（$m$为$n$个自然数中不相同数的个数），按照自然数从小到大的顺序输出。

每行输出$2$个整数，分别是自然数和该数出现的次数，其间用一个空格隔开。

## 样例 #1

### 样例输入 #1

```
8
2
4
2
4
5
100
2
100
```

### 样例输出 #1

```
2 3
4 2
5 1
100 2
```

## 提示

$40\%$的数据满足：$1  \le  n  \le  1000$

$80\%$的数据满足：$1  \le  n  \le  50000$

$100\%$的数据满足：$1  \le  n  \le  200000$，每个数均不超过$1500 000 000(1.5 \times 10^9)$

NOIP 2007 提高第一题

## 题解

第一反应是桶排，不幸的是数据范围超了。考虑使用 STL 中的 `map` 和 `heap`，前者存每个数的出现次数，后者统计出现过的数并按照大小顺序排列。

## 代码

- AC Code

```c++
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1500000000 + 5;

int n;
map<int, int> mp;
priority_queue<int, vector<int>, greater<int>> h;

int main() {
    // freopen("./in.txt", "r", stdin);
    scanf("%d", &n);
    for (int i = 1, x; i <= n; i++) {
        scanf("%d", &x);
        if (!mp[x])
            mp[x] = 1, h.push(x);
        else
            mp[x]++;
    }
    while (!h.empty()) {
        printf("%d %d\n", h.top(), mp[h.top()]);
        h.pop();
    }
    return 0;
}
```
