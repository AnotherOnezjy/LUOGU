# 数列分段 Section II

## 题目描述

对于给定的一个长度为 N 的正整数数列 $A_{1\sim N}$，现要将其分成 $M$（$M\leq N$）段，并要求每段连续，且每段和的最大值最小。

关于最大值最小：

例如一数列 $4\ 2\ 4\ 5\ 1$ 要分成 $3$ 段。

将其如下分段：

$$[4\ 2][4\ 5][1]$$

第一段和为 $6$，第 $2$ 段和为 $9$，第 $3$ 段和为 $1$，和最大值为 $9$。

将其如下分段：

$$[4][2\ 4][5\ 1]$$

第一段和为 $4$，第 $2$ 段和为 $6$，第 $3$ 段和为 $6$，和最大值为 $6$。

并且无论如何分段，最大值不会小于 $6$。

所以可以得到要将数列 $4\ 2\ 4\ 5\ 1$ 要分成 $3$ 段，每段和的最大值最小为 $6$。

## 输入格式

第 $1$ 行包含两个正整数 $N,M$。

第 $2$ 行包含 $N$ 个空格隔开的非负整数 $A_i$，含义如题目所述。

## 输出格式

一个正整数，即每段和最大值最小为多少。

## 样例 #1

### 样例输入 #1

```
5 3
4 2 4 5 1
```

### 样例输出 #1

```
6
```

## 提示

对于 $20\%$ 的数据，$N\leq 10$。

对于 $40\%$ 的数据，$N\leq 1000$。

对于 $100\%$ 的数据，$1\leq N\leq 10^5$，$M\leq N$，$A_i < 10^8$， 答案不超过 $10^9$。

## 题解

简单回顾一下二分答案。此题中答案的分布具有一定的规律，即存在一个分界点 $p$，使得 $[l, p)$ 中的数都是非法解，而 $[p, r)$ 中的数都是可行解，此时分界点 $p$ 就是我们要求的最小合法解。这种性质启示我们用一种特定的方法来枚举答案，就是**二分答案**。

此题的 `check​` 函数可以这样设计：

```c++
bool check(int x) {
    int cnt = 1, cur = 0;
    for (int i = 1; i <= n; i++) {
        if (cur + a[i] > x) cur = 0, cnt++;
        cur += a[i];
    }
    return cnt <= m;
}
```

用 cnt 记录当前段数，cur 记录当前统计的段中的数字之和，每当 cur 加上当前数字超过了设定的答案 $x$ 时，就清空 cur，并将计数器 cnt 加一。我们认为 cnt 不大于 $m$ 的情况是合法的，因为可以通过调整每段中的数字个数使得总段数恰好等于 $m$。二分的下界为数字中的最大值，上界为所有数之和。

`check` 函数中 cnt 初始值设为 1，是因为 cnt++ 的过程对应划分过程，每次加上 1 就相当于“砍”一刀增加了一段，而开始时已经有一段，也就是原始序列本身。

- AC Code

```c++
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e5 + 5;

int n, m;
int a[MAXN];
int L = -1, R = 0;

bool check(int x) {
    int cnt = 1, cur = 0;
    for (int i = 1; i <= n; i++) {
        if (cur + a[i] > x) cur = 0, cnt++;
        cur += a[i];
    }
    return cnt <= m;
}

int res;

int main() {
    // freopen("./in.txt", "r", stdin);
    scanf("%d %d", &n, &m);
    for (int i = 1; i <= n; i++)
        scanf("%d", &a[i]), L = max(L, a[i]), R += a[i];
    while (L <= R) {
        int M = L + (R - L) / 2;
        if (check(M))
            R = M - 1, res = M;
        else
            L = M + 1;
    }
    printf("%d\n", res);
    return 0;
}
```

这类问题的实质在于枚举答案，而二分只是枚举答案的一种方式，我们还可以换成其它方式。直接枚举由于太过朴素无法通过评测，这里可以使用**倍增答案**。

```c++
int p = 1, j = R;
while (p) {
    int x = j - p + 1;
    if (x >= L && check(x)) {
        res = x;
        j -= p;
        p <<= 1;
    } else
        p >>= 1;
}
```

倍增答案的时间复杂度和二分答案相同，几乎能完成所有二分答案的题目。
