# [NOIP2011 提高组] 选择客栈

## 题目描述

丽江河边有 $n$ 家很有特色的客栈，客栈按照其位置顺序从 $1$ 到 $n$ 编号。每家客栈都按照某一种色调进行装饰（总共 $k$ 种，用整数 $0 \sim k-1$ 表示），且每家客栈都设有一家咖啡店，每家咖啡店均有各自的最低消费。

两位游客一起去丽江旅游，他们喜欢相同的色调，又想尝试两个不同的客栈，因此决定分别住在色调相同的两家客栈中。晚上，他们打算选择一家咖啡店喝咖啡，要求咖啡店位于两人住的两家客栈之间（包括他们住的客栈），且咖啡店的最低消费不超过 $p$ 。

他们想知道总共有多少种选择住宿的方案，保证晚上可以找到一家最低消费不超过 $p$ 元的咖啡店小聚。

## 输入格式

共 $n+1$ 行。

第一行三个整数 $n, k, p$，每两个整数之间用一个空格隔开，分别表示客栈的个数，色调的数目和能接受的最低消费的最高值；

接下来的 $n$ 行，第 $i+1$ 行两个整数，之间用一个空格隔开，分别表示 $i $ 号客栈的装饰色调 $a_i$ 和 $i$ 号客栈的咖啡店的最低消费 $b_i$。

## 输出格式

一个整数，表示可选的住宿方案的总数。

## 样例 #1

### 样例输入 #1

```
5 2 3
0 5
1 3
0 2
1 4
1 5
```

### 样例输出 #1

```
3
```

## 提示

### 样例解释

![](https://cdn.luogu.com.cn/upload/pic/101.png)

2 人要住同样色调的客栈，所有可选的住宿方案包括：住客栈 ①③，②④，②⑤，④⑤，但是若选择住 $4,5$号客栈的话，$4,5$ 号客栈之间的咖啡店的最低消费是 $4$ ，而两人能承受的最低消费是 $3$ 元，所以不满足要求。因此只有前 $3$ 种方案可选。

### 数据范围

- 对于 $30\% $ 的数据，有 $n \leq 100$ ；
- 对于 $50\% $ 的数据，有 $n \leq 1\,000$；
- 对于 $100\%$ 的数据，有 $2 \leq n \leq 2 \times 10^5$，$1 \leq k
 \leq 50$，$0 \leq p \leq 100$，$0 \leq b_i \leq 100$。

## 题解

概括一下题意：找到这样的区间 `[a, b]`，满足：

- 区间端点 `a`、`b` 颜色相同
- 区间内（包括端点）存在某个点的数值不超过 p

求这样的区间共有多少对。

下面介绍一种 $O(n)$ 的做法，通过枚举每个 $b$，找到符合条件的 $a$ 的数量。

定义一个变量 t，记录当前枚举过程中**最近**的最低消费不超过 p 的客栈的**下标**。在枚举 $b$ 时，符合条件的 $a$ 一定在 t 前面（包括 t），这样就满足了第二个条件；而符合条件的 $a$ 的个数，就是**在 t 前面和 $b$ 颜色相同的客栈的个数**。于是我们还需要一个数组，实时更新在 t 前面各个颜色的客栈的数量。

## 代码

- AC Code

```c++
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 2e5 + 5, MAXK = 50 + 5;

int n, k, p, t, res;   //t 记录枚举过程中最低消费不超过 p 的客栈下标
int a[MAXN], num[MAXK];//num 数组实时记录 t 之前各个色调的客栈数量

int main() {
    // freopen("./in.txt", "r", stdin);
    scanf("%d %d %d", &n, &k, &p);
    for (int i = 1, b; i <= n; i++) {
        scanf("%d %d", &a[i], &b);//色调，最低消费
        if (b <= p) {
            for (int j = i; j > t; j--) num[a[j]]++;
            res += num[a[i]] - 1;
            t = i;
        } else
            res += num[a[i]];
    }
    printf("%d\n", res);
    return 0;
}
```
