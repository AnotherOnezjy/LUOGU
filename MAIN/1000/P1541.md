# [NOIP2010 提高组] 乌龟棋

## 题目背景

小明过生日的时候，爸爸送给他一副乌龟棋当作礼物。

## 题目描述

乌龟棋的棋盘是一行$N$个格子，每个格子上一个分数（非负整数）。棋盘第 1 格是唯一的起点，第$N$格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。

乌龟棋中$M$张爬行卡片，分成 4 种不同的类型（$M$张卡片中不一定包含所有$4$种类型的卡片，见样例），每种类型的卡片上分别标有$1,2,3,4$四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。游戏中，玩家每次需要从所有的爬行卡片中选择一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的格子数，每张卡片只能使用一次。

游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的分数总和。

很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同，小明想要找到一种卡片使用顺序使得最终游戏得分最多。

现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到多少分吗？

## 输入格式

每行中两个数之间用一个空格隔开。

第$1$行$2$个正整数$N,M$，分别表示棋盘格子数和爬行卡片数。

第$2$行$N$个非负整数，$a_1,a_2,…,a_N$，其中$a_i$表示棋盘第$i$个格子上的分数。

第$3$行$M$个整数，$b_1,b_2,…,b_M$，表示 M 张爬行卡片上的数字。

输入数据保证到达终点时刚好用光$M$张爬行卡片。

## 输出格式

$1$个整数，表示小明最多能得到的分数。

## 样例 #1

### 样例输入 #1

```
9 5
6 10 14 2 8 8 18 5 17
1 3 1 2 1
```

### 样例输出 #1

```
73
```

## 提示

每个测试点$1s$

小明使用爬行卡片顺序为$1,1,3,1,2$,得到的分数为$6+10+14+8+18+17=73$。注意，由于起点是$1$，所以自动获得第$1$格的分数$6$。

对于$30\%$的数据有$1≤N≤30,1≤M≤12$。

对于$50\%$的数据有$1≤N≤120,1≤M≤50$，且$4$种爬行卡片，每种卡片的张数不会超过$20$。

对于$100\%$的数据有$1≤N≤350,1≤M≤120$，且$4$种爬行卡片，每种卡片的张数不会超过$40$；$0≤a_i≤100,1≤i≤N,1≤b_i≤4,1≤i≤M$。

## 题解

本题属于动态规划中的背包问题。

定义如下变量：

- `dp[c1][c2][c3][c4]`：表示分别出 c1、c2、c3、c4 张 1、2、3、4 号卡片时的总得分
- `cardCnt[i]`：表示 i 号牌的数量

输入如下：

```c++
    for (int i = 1; i <= n; i++) scanf("%d", &score[i]);
    for (int i = 1, x; i <= m; i++)
        scanf("%d", &x), cardCnt[x]++;
```

初始状态 `dp[0][0][0][0] = score[1]`，乌龟在起点时已经获得这个格子的分数。之后对于每一张卡片，都有用和不用两种选择，当然最终所有的卡片都会用上。

不妨考虑选择了 c1、c2、c3、c4 张 1、2、3、4 号卡片的情况，以 1 号卡片为例，有转移方程：

$$
dp[c_1][c_2][c_3][c_4] = \max(dp[c_1][c_2][c_3][c_4], dp[c_1 - 1][c_2][c_3][c_4] + score[idx])
$$

其中 idx = 1 + c1 + c2 _ 2 + c3 _ 3 + c4 \* 4，因为从 1 开始所以需要加 1。

这实际上就是一个“物品所占空间”为 1”，“价值”为 `score[idx]` 的多重背包。

整体的状态转移方程为：

$$
dp[c_1][c_2][c_3][c_4] = \max(dp[c_1 - 1][c_2][c_3][c_4], dp[c_1 - 1][c_2][c_3][c_4], dp[c_1][c_2 - 1][c_3][c_4], dp[c_1][c_2][c_3 - 1][c_4], dp[c_1][c_2][c_3][c_4 - 1]) + score[idx]
$$

## 代码

- AC Code

```c++
#include <bits/stdc++.h>
using namespace std;
const int MAXC = 40 + 5, MAXN = 350 + 5;

int n, m;
int cardCnt[5], score[MAXN];
int dp[MAXC][MAXC][MAXC][MAXC];

int main() {
    // freopen("./in.txt", "r", stdin);
    scanf("%d %d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%d", &score[i]);
    for (int i = 1, x; i <= m; i++)
        scanf("%d", &x), cardCnt[x]++;
    dp[0][0][0][0] = score[1];
    for (int c1 = 0; c1 <= cardCnt[1]; c1++) {
        for (int c2 = 0; c2 <= cardCnt[2]; c2++) {
            for (int c3 = 0; c3 <= cardCnt[3]; c3++) {
                for (int c4 = 0; c4 <= cardCnt[4]; c4++) {
                    int idx = 1 + c1 + c2 * 2 + c3 * 3 + c4 * 4;
                    if (c1) dp[c1][c2][c3][c4] = max(dp[c1][c2][c3][c4], dp[c1 - 1][c2][c3][c4] + score[idx]);
                    if (c2) dp[c1][c2][c3][c4] = max(dp[c1][c2][c3][c4], dp[c1][c2 - 1][c3][c4] + score[idx]);
                    if (c3) dp[c1][c2][c3][c4] = max(dp[c1][c2][c3][c4], dp[c1][c2][c3 - 1][c4] + score[idx]);
                    if (c4) dp[c1][c2][c3][c4] = max(dp[c1][c2][c3][c4], dp[c1][c2][c3][c4 - 1] + score[idx]);
                }
            }
        }
    }
    printf("%d\n", dp[cardCnt[1]][cardCnt[2]][cardCnt[3]][cardCnt[4]]);
    return 0;
}
```
