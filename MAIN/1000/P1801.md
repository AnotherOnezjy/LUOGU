# 黑匣子

## 题目描述

Black Box 是一种原始的数据库。它可以储存一个整数数组，还有一个特别的变量 $i$。最开始的时候 Black Box 是空的．而 $i=0$。这个 Black Box 要处理一串命令。

命令只有两种：

- `ADD(x)`：把 $x$ 元素放进 Black Box;

- `GET`：$i$ 加 $1$，然后输出 Black Box 中第 $i$ 小的数。

记住：第 $i$ 小的数，就是 Black Box 里的数的按从小到大的顺序排序后的第 $i$ 个元素。

我们来演示一下一个有 11 个命令的命令串。（如下表所示）

| 序号 | 操作         | $i$ | 数据库               | 输出 |
| :--: | :----------- | :-: | -------------------- | :--: |
|  1   | `ADD(3)`     | $0$ | $3$                  |  /   |
|  2   | `GET`        | $1$ | $3$                  | $3$  |
|  3   | `ADD(1)`     | $1$ | $1,3$                |  /   |
|  4   | `GET`        | $2$ | $1,3$                | $3$  |
|  5   | `ADD(-4)`    | $2$ | $-4,1,3$             |  /   |
|  6   | `ADD(2)`     | $2$ | $-4,1,2,3$           |  /   |
|  7   | `ADD(8)`     | $2$ | $-4,1,2,3,8$         |  /   |
|  8   | `ADD(-1000)` | $2$ | $-1000,-4,1,2,3,8$   |  /   |
|  9   | `GET`        | $3$ | $-1000,-4,1,2,3,8$   | $1$  |
|  10  | `GET`        | $4$ | $-1000,-4,1,2,3,8$   | $2$  |
|  11  | `ADD(2)`     | $4$ | $-1000,-4,1,2,2,3,8$ |  /   |

现在要求找出对于给定的命令串的最好的处理方法。`ADD` 命令共有 $m$ 个，`GET` 命令共有 $n$ 个。现在用两个整数数组来表示命令串：

1. $a_1,a_2,\cdots,a_m$：一串将要被放进 Black Box 的元素。例如上面的例子中 $a=[3,1,-4,2,8,-1000,2]$。

2. $u_1,u_2,\cdots,u_n$：表示第 $u_i$ 个元素被放进了 Black Box 里后就出现一个 `GET` 命令。例如上面的例子中 $u=[1,2,6,6]$ 。输入数据不用判错。

## 输入格式

第一行两个整数 $m$ 和 $n$，表示元素的个数和 `GET` 命令的个数。

第二行共 $m$ 个整数，从左至右第 $i$ 个整数为 $a_i$，用空格隔开。

第三行共 $n$ 个整数，从左至右第 $i$ 个整数为 $u_i$，用空格隔开。

## 输出格式

输出 Black Box 根据命令串所得出的输出串，一个数字一行。

## 样例 #1

### 样例输入 #1

```
7 4
3 1 -4 2 8 -1000 2
1 2 6 6
```

### 样例输出 #1

```
3
3
1
2
```

## 提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，$1 \leq n,m \leq 10^{4}$。
- 对于 $50\%$ 的数据，$1 \leq n,m \leq 10^{5}$。
- 对于 $100\%$ 的数据，$1 \leq n,m \leq 2 \times 10^{5},|a_i| \leq 2 \times 10^{9}$，保证 $u$ 序列单调不降。

## 题解

有两种方法可以较好地解决此题。

### 1. 对顶堆

对顶堆是由两个堆组成的一种数据结构，如图所示。

<img src="../PIC/SOLUTION/%E5%AF%B9%E9%A1%B6%E5%A0%86%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="对顶堆示意图" style="zoom:33%;" />

上面是一个**小根堆**，下面是一个**大根堆**。按照这样的方式组织数据，每一层节点从上往下**逐层递减**。为方便叙述，下面称小根堆为 `min_heap`，大根堆为 `max_heap`。

由于每次查询需要得到第 $i$ 大的元素，根据上面的示意图我们维持下面的 `max_heap` 包含 $i$ 个元素，这样 `max_heap` 的堆顶就是序列中第 $i$ 大的元素。但这样做存在问题。每次循环时 $i$ 会自增，如果只是在 `max_heap` 中插入元素，有可能不会与 `min_heap` 进行元素交换，这样无法保证 `max_heap` 中的元素恒小于 `min_heap` 中的元素。我们做出如下调整：维持 `max_heap` 包含 $i - 1$ 个元素，这样 `max_heap` 的堆顶就是序列中第 $i - 1$ 大的元素，而 `min_heap` 的堆顶才是第 $i$ 大的元素。

#### 代码

- AC Code

```c++
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 2e5 + 5;

int m, n;
int a[MAXN];
int idx = 1;

priority_queue<int, vector<int>> h1;              //大根堆 h1
priority_queue<int, vector<int>, greater<int>> h2;//小根堆 h2

int main() {
    // freopen("./in.txt", "r", stdin);
    scanf("%d %d", &m, &n);
    for (int i = 1; i <= m; i++) scanf("%d", &a[i]);
    for (int i = 1, u; i <= n; i++) {
        scanf("%d", &u);
        while (idx <= u) {
            h1.push(a[idx++]);
            if (h1.size() == i)
                h2.push(h1.top()), h1.pop();//保证大根堆的元素个数为 i - 1
        }
        printf("%d\n", h2.top());   //小根堆堆顶为第 i 大元素
        h1.push(h2.top()), h2.pop();//修正大根堆元素个数，为下一次循环做准备
    }
    return 0;
}
```

### 2. 平衡树

手写代码要求较高，参考[链接](https://www.luogu.com.cn/problem/solution/P1801)