# IPv6 地址压缩

## 题目背景

（友情提示：IPv6 基础知识曾多次出现在 NOIP 初赛中）Internet Protocol，互联网协议，即为我们常说的 IP。我们目前常说的 IP 主要指它的第四版，即 IPv4，它由 IETF 于 1981 年发布。它的地址长度是 32 个二进制位，因此也就有 2^32 个 IP 地址可供使用，约为 43 亿，在当时，谁也没有料想到 IPv4 如此庞大的地址长度会有用完的一天。

在 21 世纪的今天，互联网的蓬勃发展早就了我们如今便利的生活。当下，世界人口已超过 70 亿，计算机和各种联网设备已经走入千家万户，而不再仅是上个世纪 80 年代科学家们的工具。此时便出现了人们日益增长的联网设备需要同落后 IPv4 地址长度之间的矛盾。尽管可以通过网络地址翻译能技术来共享 IP 地址，临时解决枯竭的问题，但显然不是长久之计。

IETF 也有先见之明，早早地于 1998 年发布了 IPv6 协议，从微软 2006 年发布的 Windows Vista 开始成为默认安装的网络协议。作为 IPv4 的继任者，它的地址长度为 128 个二进制位，也就是 2^128 个 IP 地址可供使用。然而面对这冗长的地址，一位记忆力不好的网络工程师小明在配置路由表时遇到了许许多多多的困难，现在他找到了你，希望你帮忙编写一个程序来按照 IPv6 地址标准的格式压缩规则来压缩 IPv6 地址。

## 题目描述

IPv6 格式

IPv6 二进位制下为 128 位长度，以 16 位为一组，每组以冒号“:”隔开，可以分为 8 组，每组以 4 位十六进制方式表示。

例如：2001:0db8:0000:0000:0123:4567:89ab:cdef 是一个合法的 IPv6 地址。

同时 IPv6 地址在某些条件下可以压缩：

1. 每组数字代表的独立 16 进制数可以省略前位的 0。

例如上面的 IPv6 地址可被压缩为：

2001:db8:0:0:123:4567:89ab:cdef

2. 可以用双冒号“::”表示一组 0 或多组连续的 0，但只能出现一次

例如上面的 IPv6 地址可被压缩为：

2001:db8::123:4567:89ab:cdef

请你帮助记忆力不好的网络工程师小明解决他遇到的问题。

规则补充：

1. 输入数据为完全展开的 IPv6 地址，确保输入的 IPv6 地址不含双冒号，每组地址省略的 0 都会被补充上去。

2. 双冒号只能使用一次，因此我们压缩最长的全 0 组

比如：2001:0db8:0000:0000:1:0000:0000:0000

我们压缩为 2001:db8:0:0:1::，而非 2001:db8::1:0:0:0

3. 双冒号只能只用一次，因此我们在我们遇到地址中多个连续全 0 组长度相同时，我们压缩最前面的一个。

2001:0db8:0000:0000:ffff:0000:0000:1

压缩为 2001:db8::ffff:0:0:1，而非 2001:db8:0:0:ffff::1

4. 输入的 IPv6 地址可能无法被压缩，因此请照原样输出。

提示：本题所示的压缩规则与 macOS(Darwin)默认的 IPv6 地址显示方式相同，而 Windows 和 Linux 只遇到一组全 0 时不会使用::进行压缩。但用此方法压缩过的 IPv6 地址一样可以被 Windows 和 Linux 正确识别。

例如：2001:0db8:ffff:0000:0123:4567:89ab:cdef

Darwin 压缩为：2001:db8:ffff::123:4567:89ab:cdef

Linux、Windows 压缩为：2001:db8:ffff:0:123:4567:89ab:cdef

## 输入格式

一串 39 个字符的字符串，代表一个完全展开的 IPv6 地址

## 输出格式

一串压缩后的 IPv6 地址

## 样例 #1

### 样例输入 #1

```
2406:0840:f990:0000:0000:0000:0000:0001
```

### 样例输出 #1

```
2406:840:f990::1
```

## 样例 #2

### 样例输入 #2

```
2001:0db8:0000:0000:0000:0000:0000:0001
```

### 样例输出 #2

```
2001:db8::1
```

## 样例 #3

### 样例输入 #3

```
2001:4860:4860:0000:0000:0000:0000:8888
```

### 样例输出 #3

```
2001:4860:4860::8888
```

## 样例 #4

### 样例输入 #4

```
2400:8900:e000:0010:0000:0000:0000:0000
```

### 样例输出 #4

```
2400:8900:e000:10::
```

## 样例 #5

### 样例输入 #5

```
0000:0000:0000:0000:0000:0000:0000:0000
```

### 样例输出 #5

```
::
```

## 样例 #6

### 样例输入 #6

```
0000:0000:0000:0000:0000:0000:0000:0001
```

### 样例输出 #6

```
::1
```

## 样例 #7

### 样例输入 #7

```
2001:0db8:ffff:0000:0123:4567:89ab:cdef
```

### 样例输出 #7

```
2001:db8:ffff::123:4567:89ab:cdef
```

## 样例 #8

### 样例输入 #8

```
1234:5678:9abc:def0:1234:5678:9abc:def0
```

### 样例输出 #8

```
1234:5678:9abc:def0:1234:5678:9abc:def0
```

## 样例 #9

### 样例输入 #9

```
0001:0000:0000:0000:0000:0000:0000:0001
```

### 样例输出 #9

```
1::1
```

## 样例 #10

### 样例输入 #10

```
0000:0000:0000:0000:0000:0000:0001:0002
```

### 样例输出 #10

```
::1:2
```

## 题解

考虑将 ipv6 地址字符串的第 0 位补上一个字符 `:`，这样就可以将 1 个 `:` 和 4 个地址字符共 5 个字符视为一组，而这样的组共有 8 个。

首先进行一次遍历找到最长的全 0 组。这里采用按组遍历的方法，用 `组标号 * 分组大小 + 组内偏移` 的方式访问元素。此处分组大小为 5，组标号从 0 到 7，访问地址字符所使用的组内偏移从 1 到 4。当发现更长的全 0 组时，除了需要更新最大长度以外，还需要记录这个更长的全 0 组的起始位置，可以用 `当前组标号 - 全 0 组长度 + 1` 的方式计算出起始组的标号。

然后再次进行遍历，根据第一次遍历的信息决定怎样输出。如果存在全 0 组，当遍历下标 $k$ 等于起始组标号时，直接将 $k$ 加上最大全 0 组长度，处理全 0 组之后的组；对于那些以 0 开头的但不是全 0 的组，输出时舍去头部的 0 即可；而对于那些自身全 0 但不属于最长全 0 组的组，需要输出一个字符 `'0'`。

细节方面还有组与组之间的分隔符 `:` 的输出。对于最大全 0 组从第 0 组开始的，开头需要补一个 `:`；对于最大全 0 组包括第 7 组（即最后一组）的，末尾需要补一个 `:`。

## 代码

- AC Code

```c++
#include <bits/stdc++.h>
using namespace std;

int t = 10;
int zeroLen, maxZeroLen = 0;
int maxLenIdx = -1;

char addr[45];

int main() {
    // freopen("./in.txt", "r", stdin);
    scanf("%s", addr + 1);
    for (int k = 0; k < 8; k++) {//8 个分组
        bool allZero = true;
        for (int i = k * 5 + 1; i <= k * 5 + 4; i++) {
            if (addr[i] != '0') allZero = false;
        }
        if (allZero) {
            ++zeroLen;
            if (zeroLen > maxZeroLen) {
                maxZeroLen = zeroLen;
                maxLenIdx = k - zeroLen + 1;
            }
        } else
            zeroLen = 0;
    }
    for (int k = 0; k < 8;) {
        if (k) putchar(':');
        if (maxLenIdx != -1 && k == maxLenIdx) {
            k += maxZeroLen;
            if (maxLenIdx == 0) putchar(':');
            if (k >= 8) putchar(':');
            continue;
        }
        bool startWithZero = true;
        for (int i = k * 5 + 1; i <= k * 5 + 4; i++) {
            if (startWithZero && addr[i] == '0') continue;
            startWithZero = false;
            putchar(addr[i]);
        }
        if (startWithZero) {
            if (k >= maxLenIdx && k < maxLenIdx + maxZeroLen) {
                k++;
                continue;
            }
            putchar('0');
        }
        k++;
    }
    return 0;
}
```
