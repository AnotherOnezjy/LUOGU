# 松江 1843 路

## 题目描述

涞坊路是一条长 L 米的道路，道路上的坐标范围从 0 到 L，路上有 N 座房子，第 i 座房子建在坐标为 x[i]的地方，其中住了 r[i]人。

松江 1843 路公交车要在这条路上建一个公交站，市政府希望让最多的人得到方便，因此希望所有的每一个的居民，从家到车站的距离的**总和**最短。

公交站应该建在哪里呢？

## 输入格式

第一行输入 L、N。

接下来 N 行，每行两个整数 x[i]和 r[i]。

## 输出格式

一个整数，最小的每个人从家到车站的距离的总和。

## 样例 #1

### 样例输入 #1

```
100 3
20 3
50 2
70 1
```

### 样例输出 #1

```
110
```

## 样例 #2

### 样例输入 #2

```
100 2
0 1
100 10
```

### 样例输出 #2

```
100
```

## 样例 #3

### 样例输入 #3

```
10000000000 5
3282894320 391
4394338332 929
6932893249 181
7823822843 440
9322388365 623
```

### 样例输出 #3

```
5473201404068
```

## 提示

样例解释 1

当建在坐标 40 的时候，所有人距离车站的距离总和为 |20−40|×3+|50−40|×2+|70−40|×1=110。

数据范围和约定

对于 10%的数据，1≤N≤50，R[i]=1。

对于 30%的数据，1≤N≤100，R[i]≤10，1≤L≤1000。

对于 70%的数据，1≤N≤1000，R[i]≤100，1≤L≤10^6。

对于全部数据，1≤L≤10^10，1≤N≤10^5，0≤x[i]≤L，1≤r[i]≤1000

## 题解

首先将房子按照坐标排序，考虑将车站建在第一间房子的位置上，不断向右移动，寻找合适的位置。

这道题实际上等价于求使得 $\sum_{i=1}^{n} |a_i - a_d|$ 最小的 $d$。

每次向右移动一个坐标，题述中的总和会增加或减少。对于所有车站左边的居民，他们到车站的距离会增加一个坐标，而对于车站右边的居民，他们到车站的距离会减少一个坐标。这样我们可以计算每一次移动对于总和的贡献，如果贡献为负说明有利，因为总和减少了，反之则不利。

容易发现，只有当车站到达居民点的时候，向右移动贡献会发生变化，因此我们可以只枚举车站在居民点的情况。所以我们如果移到一个点，到此为止贡献为负，再往右移贡献为正，那么公交站就要建在这里（如果有一个是 0 那么这一段都可以）。

用变量描述，设车站建在 $d$ 处，用 $L_i$ 和 $R_i$ 表示坐标为 $i$ 处点的前缀和与后缀和，则 $d$ 是满足 $L_i \geq R_i$ 的最左点，也即 $L_i \times 2 \geq S$，$S$ 为总前缀和（后缀和）。

## 代码

- AC Code

```c++
#include <bits/stdc++.h>
#define LL long long
using namespace std;
const LL MAXL = 1e10;
const int MAXN = 1e5;

LL l, tot, cur, res;
int n, pos;

struct house {
    LL x;
    int r;
    house(LL x = 0, int r = 0) : x(x), r(r) {}
    bool operator<(const house &h) const { return x < h.x; }
} houses[MAXN];

int main() {
    // freopen("./in.txt", "r", stdin);
    scanf("%lld %d", &l, &n);
    for (int i = 1; i <= n; i++) {
        scanf("%lld %d", &houses[i].x, &houses[i].r);
        tot += houses[i].r;
    }
    sort(houses + 1, houses + 1 + n);
    for (int i = 1; i <= n; i++) {
        cur += houses[i].r;
        if (cur * 2 >= tot) {
            pos = i;
            break;
        }
    }
    for (int i = 1; i <= n; i++)
        res += abs(houses[i].x - houses[pos].x) * houses[i].r;
    printf("%lld\n", res);
    return 0;
}
```
