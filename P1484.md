# 种树

## 题目描述

cyrcyr 今天在种树，他在一条直线上挖了 $n$ 个坑。这 $n$ 个坑都可以种树，但为了保证每一棵树都有充足的养料，cyrcyr 不会在相邻的两个坑中种树。而且由于 cyrcyr 的树种不够，他至多会种 $k$ 棵树。假设 cyrcyr 有某种神能力，能预知自己在某个坑种树的获利会是多少（可能为负），请你帮助他计算出他的最大获利。

## 输入格式

第一行，两个正整数 $n,k$。

第二行，$n$ 个整数，第 $i$ 个数表示在直线上从左往右数第 $i$ 个坑种树的获利。

## 输出格式

输出 $1$ 个数，表示 cyrcyr 种树的最大获利。

## 样例 #1

### 样例输入 #1

```
6 3
100 1 -1 100 1 -1
```

### 样例输出 #1

```
200
```

## 提示

对于 $20\%$ 的数据，$n\leq 20$。

对于 $50\%$ 的数据，$n\leq 6000$。

对于 $100\%$ 的数据，$n\leq 500000$，$k\leq \dfrac{n}{2}$，在一个地方种树获利的绝对值在 $10^6$ 以内。

## 题解

若数据量不大可以采用动态规划方法：用 $f[i][j]$ 表示考虑到第 $i$ 棵树且种植了 $j$ 棵树时的最大获利，则状态转移方程为：
$$
f[i][j] = \max (f[i-1][j], f[i-2][j-1] + a[i])
$$
但此题 $n \leq 500000$，动规算法的空间复杂度不合要求，需要另寻他路。

我们不妨进行小范围枚举，看看有没有规律。

当 $k = 1$ 时，直接取最大的数字即可。设这 $n$ 个数为 $a_1, a_2, \cdots, a_n$，最大的数是 $a_i$；

当 $k = 2$ 时，**只有两种**可能：

- 取最大数 $a_i$ 和另一个不与 $a_i$ 相邻的较大数 $a_j$；
- 取 $a_{i-1}$ 和 $a_{i+1}$。

第一种情况比较好理解。对于第二种情况，可以证明 $a_{i-1}$ 和 $a_{i+1}$ **要么同时被选，要么同时落选**。假设序列足够长，我们考虑前三大的数，最大数已经知道是 $a_i$。如果第二大的数不与 $a_i$ 相邻即 $a_{i-1}$ 和 $a_{i+1}$ 不是第二大的数，正好符合第一种情况，这时最优解只能是选择最大数和次大数；如果第二大的数与 $a_i$ 相邻，不妨认为是 $a_{i-1}$，这时还需要考虑第三大的数的位置。如果第三大的数不是 $a_{i+1}$，此时最优解一定是选择最大数和第三大的数，因为第二大的数已经小于最大数，无论和谁搭配都不可能超过这个组合；如果第三大的数就是 $a_{i+1}$，那么正好对应 $k=2$ 的两种情况。综上所述，我们证明了 $a_{i-1}$ 和 $a_{i+1}$ 要么同时被选，要么同时落选。

有了这个前提就好办了。由于每次需要得到最大的数，我们使用大根堆（最大堆）维护数据。又因为存在选择了某个数之后，若发现选择与这个数相邻的两个数结果会更好（参考 $k=2$ 时的讨论），需要取消对这个数的选择，即做出”反悔”。实现“反悔”操作在元素的值上可以将 $a_i$ 替换为 $a_{i-1}+a_{i+1}-a_i$，而在元素的相互关系上可以对用**双向链表**组织的数据进行修改。修改完毕后，将新的结点入堆，继续循环直到条件不满足时退出。

## 代码

- AC Code

```c++
#include <bits/stdc++.h>
#define LL long long
using namespace std;
const int MAXN = 5e5 + 5;

typedef pair<int, int> node;//node.first 为值，node.second 为序号

int n, k;
int a[MAXN];
int L[MAXN], R[MAXN];
bool chosen[MAXN];
LL res;

priority_queue<node, vector<node>> h;
node tmp;

//构造双向链表
inline void createList() {
    for (int i = 1; i <= n; i++)
        L[i] = i - 1, R[i] = i + 1;
    L[n + 1] = n, R[0] = 1;
}

//修改双向链表，此处修改 x 节点的左右节点
inline void updateIdx(int x) {
    L[x] = L[L[x]], R[x] = R[R[x]];
    R[L[x]] = L[R[x]] = x;
}

int main() {
    // freopen("./in.txt", "r", stdin);
    scanf("%d %d", &n, &k);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
        h.push({a[i], i});
    }
    createList();
    while (k--) {
        do {
            tmp = h.top(), h.pop();
        } while (chosen[tmp.second]);
        if (tmp.first < 0) break;//遇到小于 0 的元素时退出
        res += tmp.first;
        int idx = tmp.second;
        a[idx] = a[L[idx]] + a[R[idx]] - a[idx];//设置新节点
        chosen[L[idx]] = chosen[R[idx]] = true;
        updateIdx(idx);
        h.push({a[idx], idx});//将“反悔”选项入堆
    }
    printf("%lld\n", res);
    return 0;
}
```

